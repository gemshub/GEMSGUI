//-------------------------------------------------------------------
// $Id: m_prfget.cpp 1360 2009-07-15 13:37:30Z gems $
//
// Implementation of TProfile class, loading, making and calc functions
//
// Rewritten from C to C++ by S.Dmytriyeva
// Copyright (C) 1995-2001 S.Dmytriyeva, D.Kulik
//
// This file is part of a GEM-Selektor library for thermodynamic
// modelling by Gibbs energy minimization
// Uses: GEM-Selektor GUI GUI DBMS library, gems/lib/gemvizor.lib
//
// This file may be distributed under the terms of GEMS4 Development
// Quality Assurance Licence (GEMS4.QAL)
//
// See http://gems.web.psi.ch/ for more information
// E-mail: gems2.support@psi.ch
//-------------------------------------------------------------------
//

#include "m_syseq.h"
#include "v_object.h"
#include "visor.h"
#include "v_ejdb_file.h"
#include "service.h"
#include "ms_rmults.h"
#include "ms_system.h"
#include "ms_mtparm.h"
#include "tmltsystem.h"
#include "node.h"

extern const char * dfAqKeyD ;
extern const char * dfAqKeyH ;
extern const char * dfAqKey3 ;
extern const char * dfAqKey2 ;
extern const char * dfAqKey1 ;
extern const char * dfAqKeyY ;
extern const char * dfGasKey ;
extern const char * dfFluKeyF;
extern const char * dfFluKey7;
extern const char * dfFluKeyP;
extern const char * dfFluKeyE;

/// Delete auto-generated aq and gas phases if already created
void TProfil::deleteAutoGenerated()
{
        if( rt[RT_PHASE].Find( dfAqKeyD ))
            rt[RT_PHASE].Del(dfAqKeyD);
        if( rt[RT_PHASE].Find( dfAqKeyH ) )
            rt[RT_PHASE].Del(dfAqKeyH);
        if( rt[RT_PHASE].Find( dfAqKeyY ) )
            rt[RT_PHASE].Del(dfAqKeyY);
        if( rt[RT_PHASE].Find( dfAqKey3 ) )
            rt[RT_PHASE].Del(dfAqKey3);
        if( rt[RT_PHASE].Find( dfAqKey2 ) )
            rt[RT_PHASE].Del(dfAqKey2);
        if( rt[RT_PHASE].Find( dfAqKey1 ) )
            rt[RT_PHASE].Del(dfAqKey1);
        if( rt[RT_PHASE].Find( dfGasKey ) )
            rt[RT_PHASE].Del(dfGasKey);
        if( rt[RT_PHASE].Find( dfFluKeyF ))
            rt[RT_PHASE].Del(dfFluKeyF);
        if( rt[RT_PHASE].Find( dfFluKey7 ) )
            rt[RT_PHASE].Del(dfFluKey7);
        if( rt[RT_PHASE].Find( dfFluKeyP ) )
            rt[RT_PHASE].Del(dfFluKeyP);
        if( rt[RT_PHASE].Find( dfFluKeyE ) )
            rt[RT_PHASE].Del(dfFluKeyE);
} 

/// Init data to ProjectMode calculate
bool TProfil::initCalcMode(const char * profileKey)
{
    isSysEq = false;
    useAqPhase = true;
    useGasPhase = true;

    // free old data
    dyn_kill();


    // Open all files in list to select
    rt[RT_PARAM].OpenAllFiles();

    bool changeAqGas = false,
         addfiles = false,
         remakeRec = false,
         loadOld = false;
    int  makeDump = 0;
    string key_templ;
    string rec_key;

    if( profileKey==0 ) // get Project record key from list
    {
       rec_key = vfKeyProfile( pVisor->window(), "Modelling Projects",
          nRT, changeAqGas, addfiles, remakeRec, loadOld, makeDump, key_templ );
      if( rec_key.empty() && !loadOld) // cancel command
          return false;
    }
    else   // read defined project
    {
       if( !rt[RT_PARAM].Find(profileKey) )
           return false;
       rec_key = string(profileKey);
    }

    if( rec_key == ALLKEY ) // new Profile mode
    {
       if( !NewProfileMode( pVisor->getElemPrMode(), remakeRec, key_templ ) )
            return false;
    }
    else  // Open existing project
    {
#ifndef oldDBusing
        if( loadOld )  // loading old DB if EJ DataBase is main
        {
            rtOld[RT_PARAM].OpenAllFiles();
            // Select old Project
            vector<string> aKeys;
            rtOld[RT_PARAM].GetKeyList( ALLKEY, aKeys, true );
            int  aSel = vfChoice(window(), aKeys, "Selection of record");
            // read/reopen old Project
            rtOld[RT_PARAM].Get( aKeys[aSel].c_str() ); // read record
            dyn_set();
            string projname = rtOld[RT_PARAM].FldKey(0);
            SetFN( true ); // reopen files of old data base
            // unload data to EJDB
            InitEJDBProject( projname );
            rtOld[RT_PARAM].SetFldKey(0, projname.c_str());
            rec_key = rtOld[RT_PARAM].PackKey();
         }
#endif
        OpenProfileMode(  rec_key, changeAqGas, addfiles, remakeRec, loadOld );
    }

#ifdef oldDBusing
    if( loadOld )  // making EJDB if old DataBase is main
        InitEJDBProject( rt[RT_PARAM].FldKey(0) );
#endif

    pVisor->Message( 0, "Loading Modelling Project",
        "Loading thermodynamic data", 80 );

    // test MTparm
    MULTIBASE *pmp = multi->pmp;
    mtparm->MTparmAlloc();
    mtparm->LoadMtparm( 25., 1.);
    pmp->T = pmp->Tc = 25. + C_to_K;
    pmp->TC = pmp->TCc = 25.;
    pmp->P = pmp->Pc = 1.;
    pmp->RT = R_CONSTANT * pmp->Tc;
    pmp->FRT = F_CONSTANT/pmp->RT;

    // test data base ICOMP  before calc
    rmults->TestIComp();

    // start settins of SYSTEM
     syst->set_def();
     syst->dyn_new();
     syst->setDefData();

    // make dump file
        if( rec_key != ALLKEY && makeDump )
        	CalcAllSystems( makeDump );

    // get first  SYSEQ
    string syskey;
    rt[RT_SYSEQ].MakeKey( RT_PARAM, syskey, RT_PARAM, 0,
      K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_END);
    rt[RT_SYSEQ].SetKey( syskey.c_str() );

   // update windows informations
   pVisor->CloseMessage();
   ModUpdate("Insertion of a Modelling Project record finished OK.");
   return true;
}

/// Opening Existing Project
void TProfil::OpenProfileMode( const string& projkey,
       bool changeAqGas, bool addFile,  bool remakeRec, bool oldDB )
{
 try
   {
        // read project record
        rt[RT_PARAM].Get( projkey.c_str() );
        string fstKeyFld = rt[RT_PARAM].FldKey(0);
        dyn_set();
        if(oldDB)
        {
          int fnum = -1;
          GetFN( fstKeyFld, false );
          rt[RT_PARAM].SaveRecord(projkey.c_str(),fnum);
        }
        // reopen files of data base
        SetFN();

        // edit flags
        if( remakeRec )
            RecBuild( projkey.c_str(), VF_REMAKE );

        // changed and reopened open DB files list
        if( addFile )
        {
           GetFN( fstKeyFld );
           SetFN();
        }

        pVisor->Message( 0, "Loading Modelling Project",
       "Opening data base files to Project", 5 );

        //rt[RT_PARAM].SetKey( key );
        SaveOldList();
        deleteAutoGenerated();

        pVisor->Message( 0, "Loading Modelling Project",
        "Loading lists of IComp, Compos, Phase\n"
                  "  and DComp/ReacDC record keys", 10 );

        // load lists of ICOMP, COMPOS, PHASE and DCOMP&REACT recordc keys
        rmults->LoadRmults( false, changeAqGas );

       pVisor->Message( 0, "Loading Modelling Project",
       "Detecting changes in thermodynamic database", 40 );

       // test and insert changes to data base file
       TestChangeProfile();
       DeleteOldList();

       // save changes to project record
       int fnum = -1;
       rt[RT_PARAM].SaveRecord( projkey.c_str(),fnum );
       contentsChanged = false;
  }
  catch( TError& xcpt )
  {
    pVisor->CloseMessage();
    rt[RT_PARAM].SetKey( "*" );
    DeleteOldList();
    deleteAutoGenerated();
    contentsChanged = false;
    throw; // going on
  }
}

/// Making new Modelling Project
bool TProfil::NewProfileMode( bool elementsMode,
   bool remakeRec, const string& key_templ )
{
 string new_project_dir_name = "";

 try
 {
    bool is_templ_key = false;
    string templfstKeyFld = "";

AGAIN:
    // get project name
    string  key_str = GetKeyofRecord( "MyWork:My1stProject:",
            "Enter a new record key, please", KEY_NEW );
    if( key_str.empty() )
      return false; // cancel command

    rt[RT_PARAM].SetKey( key_str.c_str() );
    new_project_dir_name = rt[RT_PARAM].FldKey(0);

    //Test equal project names
    string  templ_;
    templ_ = new_project_dir_name;
    templ_ += ":*:";
    vector<string> aKey__;
    if(  db->GetKeyList( templ_.c_str(), aKey__  ) > 0 )
    {
      vfMessage(window(), new_project_dir_name,
        "Project cannot be created - such directory already exists."
        "\nPlease, enter another name.");
      goto AGAIN;
    }

    // read template record
    if( !key_templ.empty() )
    {
      is_templ_key = true;
      // read record
      rt[RT_PARAM].Get( key_templ.c_str() );
      dyn_set();
      templfstKeyFld = rt[RT_PARAM].FldKey(0);
      // reopen files of data base
      SetFN();
      if( elementsMode ) // if no elements profile as template
      { if( rt[RT_ICOMP].ifDefaultOpen() )
           Error( key_templ,"This project cannot be extended using Elements Dialog.");
      }
    }
    else // set default data or zero if necessary
    {
       rt[RT_PARAM].SetKey( key_str.c_str() );
       dyn_kill();
       set_def();
       toBsonObject( (bson *)aObj[o_bspar].GetPtr() );
    }

   if( remakeRec )
     RecBuild( key_str.c_str(), VF_REMAKE );  // Edit flags
   else
     RecBuild( key_str.c_str(), VF_BYPASS );

   pVisor->Message( window(), "Loading Modelling Project",
      "Opening database files to Project", 5  );

   if( is_templ_key == false  )
        InitFN( new_project_dir_name  ); // make Project directory
   else  // using existing Project
        InitRenameFN( new_project_dir_name.c_str(), templfstKeyFld.c_str()  );

   if( elementsMode )
   {
     // Elements selection dilaog
     if( !rCopyFilterProfile( new_project_dir_name.c_str() ) )
       Error( key_str, "Project configuration aborted by the user!" );

      // get opens files list
      if( !GetFN( new_project_dir_name, false ) )
        Error( key_str, "Project configuration aborted by the user!" );
    }
    else
    {
       // get opens files list
       if( !GetFN( new_project_dir_name ) )
        Error( key_str, "Project configuration aborted by the user!" );
    }
    SetFN();

    if( is_templ_key == true  )
    {
       // test changes into template record
       SaveOldList();
       // delete auto-generated aq and gas phases if already created
       deleteAutoGenerated();
    }
    pVisor->Message( 0, "Loading Modelling Project",
      "Loading lists of IComp, Compos, Phase\n"
                "  and DComp/ReacDC record keys", 10);

    // load lists of ICOMP, COMPOS, PHASE and DCOMP&REACT recordc keys
    rt[RT_PARAM].SetKey( key_str.c_str() );
    rmults->LoadRmults( !is_templ_key /*true*/, true );

    pVisor->Message( 0, "Loading Modelling Project",
         "Detecting changes in thermodynamic database", 40 );

    if( is_templ_key == true )
    {  // test and insert changes to data base file
            TestChangeProfile();
            DeleteOldList();
     }

    // save results   RecSave(str.c_str());
    int fnum = -1;
    db->AddRecord( key_str.c_str(), fnum );
 }
 catch( TError& xcpt )
    {
      pVisor->CloseMessage();
      contentsChanged = false;

      /// must be changed foe EJDB
      string Path = pVisor->userProfDir();
      Path +=   new_project_dir_name;
      pVisor->deleteDBDir(Path);

      throw;
    }
  return true;
}


// load  SysEq and unpack data record from data base
// (for Process, GTdemo, UnSpace ... calculations)
void TProfil::loadSystat( const char *key )
{
    MULTIBASE *pmp = multi->pmp;
    TSysEq* STat = (TSysEq*)(aMod[RT_SYSEQ]);
    //  STat->ods_link(0);
    string str;

    if( key==0 )
    {
        //rt[RT_SYSEQ].MakeKey( RT_PARAM, pkey, RT_PARAM, 0,
        //                       K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_END);
        str = STat->getFilter();
        str = STat->GetKeyofRecord( str.c_str(),//pkey,
           "Existing CSD and equilibria records in project database", KEY_OLD );
        ErrorIf( str.empty(), GetName(), "Operation cancelled!");
    }
    else str=string(key);
    STat->keyTest( str.c_str() );

    // get record
    STat->RecInput( str.c_str() );

    // unpack to SYSTEM structure
    syst->loadData( false );  // set def and unpack syseq to system

    // Test MULTY for change (if new System cfg or T, P - new)
    pmp->pESU = 0;  //  new record was readed
    string keyp = rt[RT_SYSEQ].UnpackKey();
    PMtest( keyp.c_str() );
    //pmp->pTPD = 0;   // workaround 26.02.2008  DK SD 24/05/2010
    //if( pmp->pBAL < 2 || pmp->pTPD < 2)
       multi->InitalizeGEM_IPM_Data( wrknode );

    if( pmp->pESU )      // unpack old solution
    {
        multi->LoadGEM_IPM_Data( true ); // unpack syseq to multi
        multi->EqstatExpand( );
//        outMultiTxt( "GEM_EqstatExpand.txt"  );
    }

    wrknode->GEM_print_ipm( "CalculateEquilibriumEndload.txt" );
    pVisor->Update();
}

// rebuild loading before Systat
void TProfil::deriveSystat()
{
     MULTIBASE *pmp = multi->pmp;
     TSysEq::pm->setCalcFlag( false );

    string keyp = rt[RT_SYSEQ].UnpackKey();
    if( keyp.find_first_of( "*?") != string::npos )
        Error("SyStat", "Undefined current record!");
    int ret = TSysEq::pm->RecBuild( keyp.c_str(), VF_REMAKE );

    // unpack to SYSTEM structure
    syst->loadData( false, ret );  // set def and unpack syseq to system

    // Test MULTY for change (if new System cfg or T, P - new)
    pmp->pESU = 0;  //  new record was readed
    PMtest( keyp.c_str() );
    //pmp->pTPD = 0;   // workaround 26.02.2008  DK 24/05/2010
    //if( pmp->pBAL < 2 || pmp->pTPD < 2)
        multi->InitalizeGEM_IPM_Data( wrknode );
    if( pmp->pESU )      // unpack old solution
    {
        multi->LoadGEM_IPM_Data( true ); // unpack syseq to multi
        multi->EqstatExpand();
    }

    // SD 22/01/2010 bool
    if( syst->GetSY()->Pask != S_OFF )
     syst->setDefCheck();
    systbcInput( window(), keyp.c_str() );
    pVisor->Update();
    //pVisor->OpenModule(window(), MD_SYSTEM);
}

//  build new Systat record
void TProfil::newSystat( int mode )
{
    TSysEq::pm->setCalcFlag( false ); // => pmp->pESU = 0;

    string key_str = rt[RT_SYSEQ].PackKey();
    if( key_str.find("*") != string::npos )
    {
        key_str = db->FldKey(0);
        key_str += ":G:MySystem:0:0:1:25:0:";
    }
    string str = key_str;
    string capName = "Please, enter a new record key: ";

AGAIN:
    str = TSysEq::pm->GetKeyofRecord( str.c_str(),  capName.c_str(), KEY_NEW );
    if( str.empty() )
        return;
    if( rt[RT_SYSEQ].Find( str.c_str() ) )
    {
        capName = "This record already exists! Please, enter another name.";
        goto AGAIN;
        //Error("SyStat", "This record already exists!");
    }
    db->SetKey( str.c_str() );
    int ret = TSysEq::pm->RecBuild( str.c_str(), mode );
    syst->loadData( true, ret ); // set def and unpack syseq to system
    // Test MULTY for change (if new System cfg or T, P - new)
    string keyp = rt[RT_SYSEQ].UnpackKey();
    multi->pmp->pESU = 0;  //  new record was readed
    PMtest( keyp.c_str() );
    //pmp->pTPD = 0;   // workaround 26.02.2008  DK
    //if( pmp->pBAL < 2 || pmp->pTPD < 2)
    multi->InitalizeGEM_IPM_Data( wrknode );
    // ?? multi->LoadGEM_IPM_Data( false ); // unpack syseq to multi

    // SD 22/01/2010 bool
    systbcInput( window(), str.c_str() );
    pVisor->Update();
    //pVisor->OpenModule(window(), MD_SYSTEM);
}

// packed syseq arrays
void TProfil::PackSystat()
{
    TSysEq* STat = (TSysEq*)(aMod[RT_SYSEQ]);
    //  STat->ods_link(0);

    //  syst->SyTest(); //  Sveta 15/05/99 ??? do it
    syst->setSizes();
    if( isSysEq ) // add to z_sp_config show mode 07/12/99
    {
        STat->ssp->DM[22] += (short)PHoff.size();
        STat->ssp->DM[23] += (short)DCoff.size();
    }
    multi->setSizes();
    STat->dyn_new();
    if( isSysEq ) // add to z_sp_config show mode 07/12/99
        syst->packData( PHon, PHoff, DCon, DCoff);
    else syst->packData();
    if( isSysEq ) // add to z_sp_config show mode 07/12/99
        multi->packData( PHon, DCon );
    else multi->packData();

    pVisor->Update();
}

//Calculate system bulk composition        line # 300
void TProfil::CalcBcc()
{
    //     Switchoffs etc. - most important for the users!
    syst->SyTest();
    pVisor->Update();
    TSysEq::pm->CellChanged();
    syst->SyTest();               // Must be done twice
    pVisor->Update(true);         // added 24.01.00
    TSysEq::pm->CellChanged();    // DAK
}

// Calculation of equilibrium state with GEM IPM2 kernel within GEM-Selektor
// GEMS: Caution - this function is run in another thread!
// don't call any GUI (Qt or VisorImp) functions from here!
// exceptions should be kept inside the function either
// Modified on 10.09.2007 to return GEM IPM2 calculation time in seconds as double
// Parameters: kTimeStep: index of time step (>= 0) or -1 to reset kinetics;
//             kTime: current time (>= 0.0);
//             kdTime: current time step (can be changed in TKinMet class)
// Returns: elapsed calculation time in seconds
//
double TProfil::CalcEqstat( double &kdTime, const long kTimeStep, const double kTime )
{
    TSysEq* STat = (TSysEq*)(aMod[RT_SYSEQ]);
    long int NumIterFIA,  NumIterIPM, NumPrecLoops;

    MULTIBASE *pmp = multi->pmp;
    STat->ods_link(0);
//    status = 0;
    syst->SyTest();
    if( !syst->BccCalculated() )
        Error( "System", "Please, specify bulk composition of the system!");

    string keyp = rt[RT_SYSEQ].UnpackKey();
// new: setting chemical kinetics time counter and variables
// cout << "kdTime: " << kdTime << "  kTimeStep: " << kTimeStep << "  kTime: " << kTime << endl;
    if( kdTime < 0. )
    {  // no kinetics to consider
        pmp->kTau = 0.;
        pmp->kdT = 0.;
        pmp->ITau = -1; // SD 23/03/2015
        pmp->pKMM = 2;  // no need to allocate TKinMet instances
    }
    else {   // considering kinetics
        pmp->kTau = kTime;
        pmp->kdT = kdTime;
        if( kTimeStep < 0 )
        {   // we need to initialize TKinMet
            pmp->pKMM = -1;
            pmp->ITau = -1;
        }
        else  // TKinMet exists, simulation continues
             pmp->pKMM = 1; // SD 23/03/2015 multi->GetPM()->ITau = kTimeStep;
    }
    PMtest( keyp.c_str() );

#ifndef Use_mt_mode
     if( prg )
	pVisorImp->OpenProgress();
#endif
   // run GEM calculation
   ComputeEquilibriumState( NumPrecLoops, NumIterFIA, NumIterIPM );
// new - possibly returns a new time step suggestion
   if(kdTime)
       kdTime = pmp->kdT;
   return  pmp->t_elap_sec;
}


//-----------------------------------------------


#ifdef oldDBusing

/// Save file configuration to Project structure
void TProfil::InitFN( const string& prfName )
{
    string Path = pVisor->userProfDir();
    Path += prfName;

    // make directory Path (find system function)
    pVisor->makeDBDir(Path.c_str());

     // creating empty files
     for(int i=0; i<aMod.size(); i++)
      {
        if( aMod[i]->IsSubModule() )
            continue;
        rt[aMod[i]->rtNum()].MakeInNewProfile( Path, prfName );
      }
}

/// Save file configuration to Project structure using template
/// and rename records SysEq and >
void TProfil::InitRenameFN( const char* prfName, const char * prfTemplate )
{
    string Path = pVisor->userProfDir();
    Path += prfName;

    // make directory Path (find system function)
    pVisor->makeDBDir(Path.c_str());

    string tmpDirPath = pVisor->userProfDir();
    tmpDirPath += prfTemplate;

    vector<string> aFiles;
    pVisor->readPDBDir(aFiles, tmpDirPath.c_str(), "*" );

     // copy files to new Prifile
     for (int ii = 0; ii < aFiles.size(); ii++)
     {
        string f_tmp = tmpDirPath;
                f_tmp += "/";
                f_tmp += aFiles[ii];
        string f_new = Path;
                f_new += "/";
        f_new += replace( aFiles[ii], prfTemplate, prfName);

       if ( !(string( aFiles[ii], 0, aFiles[ii].find("."))
                        ==  db->GetKeywd()))
          pVisor->CopyF( f_new.c_str(), f_tmp.c_str() );
    }

    // add files to module list
    for (int ii = 0; ii < aFiles.size(); ii++)
    {
       if (string(aFiles[ii], aFiles[ii].rfind(".") + 1) == "pdb")
        {
            for (int jj = 0; jj < rt.size(); jj++)
                if (string(aFiles[ii], 0, aFiles[ii].find("."))
                        == rt[jj].GetKeywd())
                {
                  string f_new = aFiles[ii];//.replace(
                  //   prfTemplate, prfName);
                  rt[jj].MakeInNewProfile( Path, prfName, f_new.c_str() );
                }
        }
    }

    // Rename records SysEq in New Project
       TSysEq::pm->RenameList(prfName, prfTemplate);
    // Rename records in New Project > SysEq
      for(int i=RT_SYSEQ+1; i<aMod.size(); i++)
      {
        if( aMod[i]->IsSubModule() )
            continue;
        rt[i].RenameList(prfName, prfTemplate);
      }
}

/// Save file configuration to Project structure
bool TProfil::GetFN( const string& prfName, bool show_dlg )
{
    vector<string> aFls;
    vector<int> aCnt;
    if( !vfListFiles(pVisor->window(), show_dlg, prfName.c_str(), aFls, aCnt ))
      return false;

    RMULTS* mup = rmults->GetMU();
    memset(mup->Nfl, 0, MAXNUMCHAINS*sizeof(short));
    mup->NfT = 0;
    for(int i=0; i<aCnt.size(); i++)
    {
        mup->Nfl[i] = (short)aCnt[i];
        mup->NfT += mup->Nfl[i];
    }
    mup->FN = (char (*)[MAX_FILENAME_LEN])aObj[ o_mufn].Alloc(
                  aFls.size(), 1, MAX_FILENAME_LEN );
    // insert files name to FN
    for(int j=0; j<aFls.size(); j++)
        strncpy( mup->FN[j], aFls[j].c_str(), MAX_FILENAME_LEN);
    return true;
}

#else
// Working GetFN and SetFN for EJDB must be disscussed
// to do not make empty collections


/// Save file configuration to Project structure
void TProfil::InitFN( const string& prfName )
{
    string Path = pVisor->userProfDir();
    Path += prfName;

    // added new EJ DataBase
    flsEJ.addNew( Path );

    vector<string> names1;
    names1.push_back(prfName);

    // close all no project files
    for(int i=0; i<aMod.size(); i++)
     {
       if( aMod[i]->IsSubModule() )
           continue;
       rt[aMod[i]->rtNum()].OpenOnlyFromList(names1);
     }

}

/// Save file configuration to Project structure using template
/// and rename records SysEq and >
void TProfil::InitRenameFN( const char* prfName, const char* prfTemplate )
{
    int fnum = 0;
    string Path = pVisor->userEJDBProfDir();
    Path += prfName;

    // Test for existing (must be dicussed)
    if( flsEJ.FindPath( Path ) > 0 )
        Error( prfName, "Project cannot be created - such directory already exists." );

    // added new or link existing EJ DataBase
    flsEJ.addNew( Path );

    // close all no project and no template files
    vector<string> names1, names2;
    names1.push_back(prfName);
    names2.push_back(prfName);
    if( prfTemplate )
      names1.push_back(prfTemplate);

    // copy records from old DataBase project
    for(int i=0; i<aMod.size(); i++)
    {
        if( aMod[i]->IsSubModule() )
              continue;
        // close all no project files
        rtEJ[i].OpenOnlyFromList(names1);
        // get new project file num
        fnum = rtEJ[i].GetOpenFileNum( prfName );

        if( prfTemplate == 0 || i== RT_PARAM )
          continue;
        // copy records from template project
        if( i >= RT_SYSEQ /*|| i== RT_PARAM */ )
        { // change first field
           ((TCModule*)aMod[i])->CopyAllToEJDB( false,
             fnum, 0, "*"/*prfTemplate*/, prfName );
        } else
          { // change last field
           ((TCModule*)aMod[i])->CopyAllToEJDB( false,
             fnum, rtEJ[i].KeyNumFlds()-1, "*", "*_" );
          }
        // close all no project files
        rtEJ[i].OpenOnlyFromList(names2);

    }
}

/// Save file configuration to Project structure
bool TProfil::GetFN( const string& prfName, bool show_dlg )
{
    vector<string> aFls;
    vector<int> aCnt;
    if( !vfListFiles(pVisor->window(), show_dlg, prfName.c_str(), aFls, aCnt ))
      return false;

    RMULTS* mup = rmults->GetMU();
    memset(mup->Nfl, 0, MAXNUMCHAINS*sizeof(short));
    mup->NfT = 0;
    for(int i=0; i<aCnt.size(); i++)
    {
        mup->Nfl[i] = (short)aCnt[i];
        mup->NfT += mup->Nfl[i];
    }
    mup->FN = (char (*)[MAX_FILENAME_LEN])aObj[ o_mufn].Alloc(
                  aFls.size(), 1, MAX_FILENAME_LEN );
    // insert files name to FN
    for(int j=0; j<aFls.size(); j++)
        strncpy( mup->FN[j], aFls[j].c_str(), MAX_FILENAME_LEN);
    return true;
}


#endif

/// Reopen file configuration on data in Project structure
void TProfil::SetFN( bool isold )
{
    bool allOpend = true;
    unsigned i, nx=0;
    short j, k=0;
    vector<string> aFls;
    string s;

    string fstKeyFld = rt[RT_PARAM].FldKey(0);

    for( i=0; i<aMod.size(); i++)
    {
        if( aMod[i]->IsSubModule() )
            continue;

#ifdef oldDBusing

///Added after GEM2MT implemented
        if( i == RT_PARAM )
        {
            s = string( rmults->GetMU()->FN[k], 0, MAX_FILENAME_LEN);
            if( s[0] == 'i' && s[1] == 'n') // integ file , use old version DB
            { k+=rmults->GetMU()->Nfl[i];
              nx = 1;
            }
        }
///end Added after GEM2MT implemented

#endif

        aFls.clear();
        for(j=0; j<rmults->GetMU()->Nfl[i+nx]; j++)
        {
            s = string( rmults->GetMU()->FN[k++], 0, MAX_FILENAME_LEN);
            aFls.push_back(s);
        }

        if( isold )
        {
           rtOld[aMod[i]->rtNum()].SetNewOpenFileList( aFls );
        }
        else  if( !rt[aMod[i]->rtNum()].SetNewOpenFileList( aFls ))
                   allOpend = false;
        aMod[i]->dyn_set();
    }
    if( !allOpend )
    {
       GetFN( fstKeyFld, false );
    }
}

// Working with EJDB
// Copy Project structure to EJDB proj_ejdb
// Files of old Projects must be reopened before
void TProfil::InitEJDBProject( string& prfName )
{
    string Path = pVisor->userEJDBProfDir();

    // delete '_' from old project name
    string prfName_ = replace( prfName, "_", "-");
    bool newProfname = prfName_ != prfName;
    prfName = prfName_;
    Path += prfName;

    // Test for existing (must be dicussed)
    if( flsEJ.FindPath( Path ) > 0 )
        Error( prfName, "Project cannot be created - such directory already exists." );

    // added new or link existing EJ DataBase
    flsEJ.addNew( Path );

    // close all no project files
    vector<string> names1;
    names1.push_back(prfName);

    // get new project file num
    int fnum = 0; // only one file of new EJDB project must be opened

    // copy records from old DataBase project
    for(int i=0; i<aMod.size(); i++)
    {
        if( aMod[i]->IsSubModule() )
              continue;
        // close all no project files
        rtEJ[i].OpenOnlyFromList(names1);
        if( newProfname &&  ( i >= RT_SYSEQ || i== RT_PARAM)  )
        { // change first field
           ((TCModule*)aMod[i])->CopyAllToEJDB( true,
             fnum, 0, "*", prfName );
        } else
           ((TCModule*)aMod[i])->CopyAllToEJDB( true, fnum );
    }
    GetFN( prfName, false);

}

//------------------ End of m_prfget.cpp --------------------------


