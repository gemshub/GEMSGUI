//-------------------------------------------------------------------
// $Id: m_prfget.cpp 1360 2009-07-15 13:37:30Z gems $
//
// Implementation of TProfile class, loading, making and calc functions
//
// Rewritten from C to C++ by S.Dmytriyeva
// Copyright (C) 1995-2001 S.Dmytriyeva, D.Kulik
//
// This file is part of a GEM-Selektor library for thermodynamic
// modelling by Gibbs energy minimization
// Uses: GEM-Selektor GUI GUI DBMS library, gems/lib/gemvizor.lib
//
// This file may be distributed under the GPL v.3 license

//
// See http://gems.web.psi.ch/ for more information
// E-mail: gems2.support@psi.ch
//-------------------------------------------------------------------
//

#include "m_syseq.h"
#include "visor.h"


void TProfil::deleteAutoGenerated()
{
    // delete auto-generated aq and gas phases if already created
    int nRec = rt[RT_PHASE]->Find( dfAqKeyD );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfAqKeyH );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfAqKeyY );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfAqKey3 );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfAqKey2 );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfAqKey1 );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfGasKey );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfFluKeyF );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfFluKey7 );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfFluKeyP );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
    nRec = rt[RT_PHASE]->Find( dfFluKeyE );
    if( nRec >= 0 )
        rt[RT_PHASE]->Del(nRec);
} 

//Init data to ProjectMode calculate
bool
TProfil::initCalcMode(const char * profileKey)
{
    MULTI *pmp = multi_internal->GetPM();
    isSysEq = false;
    useAqPhase = true;
    useGasPhase = true;


    // free old data
    dyn_kill();
    // Open all files in list to select
    rt[RT_PARAM]->OpenAllFiles();

    // Get Project record key from old list
    bool changeAqGas = false,
            addfiles = false,
            remakeRec = false;
    int    recalc_all = 0,
           genGEMS3k = 0,
           SIA_or_AIA = 0;
    std::string key_templ;
    std::string str;

    if( profileKey==nullptr )
    {
        str = vfKeyProfile( pVisor->window()/*window()*/, "Modelling Projects",
                            nRT, changeAqGas, addfiles, remakeRec, key_templ, recalc_all, genGEMS3k, SIA_or_AIA );

        if( str.empty() ) // cancel command
            return false;
    }
    else
    {
        if( rt[RT_PARAM]->Find(profileKey) < 0)
            return false;
        str = std::string(profileKey);
    }

    if( str == ALLKEY )
    {
        if( pVisor->getElemPrMode() )
        { if(  !NewProfileModeElements( remakeRec, key_templ ) )
                return false;
        }
        else
        {    if(  !NewProfileMode( remakeRec, key_templ ) )
                return false;
        }
    }
    else
        OpenProfileMode(  str.c_str(),changeAqGas, addfiles, remakeRec );

    pVisor->Message( nullptr, "Loading Modelling Project",
                     "Loading thermodynamic data", 80 );

    // Test MTparm
    mtparm->MTparmAlloc();
    mtparm->LoadMtparm( 25., 1.);
    pmp->T = pmp->Tc = 25. + C_to_K;
    pmp->TC = pmp->TCc = 25.;
    pmp->P = pmp->Pc = 1.;
    pmp->RT = R_CONSTANT * pmp->Tc;
    pmp->FRT = F_CONSTANT/pmp->RT;


    // Start settins of SYSTEM
    syst->set_def();
    syst->dyn_new();
    syst->setDefData();

    if( str != ALLKEY )
    {
        if( genGEMS3k > 0 )
        {
            GEMS3KallSystems( SIA_or_AIA, genGEMS3k==2  );
        }
        if( recalc_all > 0 )
        {
            CalcAllSystems( SIA_or_AIA, recalc_all==2 );
        }
    }
    // Get first  SYSEQ
    char pkey[81];
    rt[RT_SYSEQ]->MakeKey( RT_PARAM, pkey, RT_PARAM, 0,
                          K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_END);
    rt[RT_SYSEQ]->SetKey( pkey );

    // update windows informations
    pVisor->CloseMessage();
    ModUpdate("Insertion of a Modelling Project record finished OK.");
    return true;
}


//Opening Existing Project
void TProfil::OpenProfileMode( const char* key,
       bool changeAqGas, bool addFile,  bool remakeRec )
{
   int Rnum = -1;
 try
 {
        Rnum = rt[RT_PARAM]->Find( key );
        ErrorIf( Rnum < 0,  key , "Project record do not exist!");

//        pVisor->Message( 0, "Loading Modelling Project",
//       "Opening data base files to Project", 5 );

        rt[RT_PARAM]->Get( Rnum ); // read record
        dyn_set();
        SetFN();                  // reopen files of data base

        if( remakeRec )   // added 13/07/2009
         RecBuild( key, VF_REMAKE );  // Edit flags

        if( addFile == true )
        {  // part to add files to list
           rt[RT_PARAM]->SetKey( key );
           std::string fstKeyFld = projectName();
           GetFN( fstKeyFld.c_str() );
           SetFN();
        }

        pVisor->Message( nullptr, "Loading Modelling Project",
       "Opening data base files to Project", 5 );

        rt[RT_PARAM]->SetKey( key );
        SaveOldList();
        deleteAutoGenerated();

        pVisor->Message( nullptr, "Loading Modelling Project",
        "Loading lists of IComp, Compos, Phase\n"
                  "  and DComp/ReacDC record keys", 10 );

        // load lists of ICOMP, COMPOS, PHASE and DCOMP&REACT recordc keys
        Rnum = rt[RT_PARAM]->Find( key );
        rmults->LoadRmults( false, changeAqGas );

       pVisor->Message( nullptr, "Loading Modelling Project",
       "Detecting changes in thermodynamic database", 40 );

   TestChangeProfile();  // test and insert changes to data base file
   DeleteOldList();
   rt[RT_PARAM]->Rep( Rnum );
   contentsChanged = false;

 }
 catch( TError& /*xcpt*/ )
 {
   pVisor->CloseMessage();
// Sveta 06/2005
        rt[RT_PARAM]->SetKey( "*" );
//   rt[RT_PARAM]->Get( Rnum );
//   dyn_set();
   DeleteOldList();

        // delete auto-generated aq and gas phases if already created
   deleteAutoGenerated();

    contentsChanged = false;
    throw; // going on
 }

}

//Making new Modelling Project
bool TProfil::NewProfileMode( bool remakeRec, std::string& key_templ__ )
{
    std::string new_project_dir_name = "";
    try
    {
        bool templ_key = false;

        std::string  templ_str;
AGAIN:
        std::string  key_str = GetKeyofRecord( "MyWork:My1stProject"/*ALLKEY*/,
                                               "Enter a new record key, please!", KEY_NEW );
        if( key_str.empty() )
            return false; // cancel command

        rt[RT_PARAM]->SetKey( key_str.c_str() );
        std::string fstKeyFld = projectName();
        new_project_dir_name = fstKeyFld;

        //Test equal project names
        templ_str = fstKeyFld;
        templ_str += ":*:";
        TCStringArray aKey__;
        TCIntArray anR__;

        if(  db->GetKeyList( templ_str.c_str(), aKey__, anR__  ) >0 )
        {
            vfMessage(window(), fstKeyFld.c_str(),
                      "Project cannot be created - such directory already exists."
                      "\nPlease, enter another name.");
            goto AGAIN;
        }

        // select project record key to template
        templ_str = key_templ__;
        if( !templ_str.empty() )
        {
            templ_key = true;

            int  Rnum = rt[RT_PARAM]->Find( templ_str.c_str() );
            ErrorIf( Rnum < 0, templ_str.c_str() ,
                     "Project record does not exist!");
            rt[RT_PARAM]->Get( Rnum ); // read record
            dyn_set();
            SetFN();                  // reopen files of data base
        }
        else
        {
            rt[RT_PARAM]->SetKey( key_str.c_str() );
            dyn_kill();
            set_def(); // set default data or zero if necessary
        }

        if( remakeRec )
            RecBuild( key_str.c_str(), VF_REMAKE );  // Edit flags
        else
            RecBuild( key_str.c_str(), VF_BYPASS );


        pVisor->Message( window(), "Loading Modelling Project",
                         "Opening database files to Project", 5  );

        rt[RT_PARAM]->SetKey( key_str.c_str() );

        if( templ_key == false  )
            InitFN( fstKeyFld.c_str(), nullptr  ); // make Project directory
        else  // using existing Project
        {
            rt[RT_PARAM]->SetKey( templ_str.c_str() );
            std::string fstKeyFld_t = projectName();
            InitFN( fstKeyFld.c_str(), fstKeyFld_t.c_str()  ); // make Project directory
            RenameFN( fstKeyFld.c_str(), fstKeyFld_t.c_str()  );
        }

        rt[RT_PARAM]->SetKey( key_str.c_str() );
        // get opens files list
        if( !GetFN( fstKeyFld.c_str() ) )
            Error( key_str,  "Project configuration aborted by the user!" );
        SetFN();

        if( templ_key == true  )
        {
            rt[RT_PARAM]->SetKey( key_str.c_str() );
            SaveOldList();

            // delete auto-generated aq and gas phases if already created
            deleteAutoGenerated();
        }
        pVisor->Message( nullptr, "Loading Modelling Project",
                         "Loading lists of IComp, Compos, Phase\n"
                         "  and DComp/ReacDC record keys", 10);

        // load lists of ICOMP, COMPOS, PHASE and DCOMP&REACT recordc keys
        rt[RT_PARAM]->SetKey( key_str.c_str() );
        rmults->LoadRmults( !templ_key /*true*/, true );

        pVisor->Message( nullptr, "Loading Modelling Project",
                         "Detecting changes in thermodynamic database", 40 );

        if( templ_key == true )
        {
            TestChangeProfile();  // test and insert changes to data base file
            DeleteOldList();
        }

        // save results   RecSave(str.c_str());
        AddRecord( key_str.c_str() );

    }
    catch( TError& /*xcpt*/ )
    {
        pVisor->CloseMessage();
        contentsChanged = false;
        //delete projct directory, if Project record create error
        std::string Path = pVisor->userProfDir();
        Path += new_project_dir_name;
        pVisor->deleteDBDir(Path.c_str());
        throw;
    }
    return true;
}

//Making new Project  (new elements mode)
bool TProfil::NewProfileModeElements( bool remakeRec, std::string& key_templ )
{
    std::string new_project_dir_name = "";
    try
    {
        bool templ_key = false;

        std::string  templ_str;
AGAIN:
        std::string  key_str = GetKeyofRecord( "MyWork:My1stProject"/*ALLKEY*/,
                                               "Enter a new record key, please", KEY_NEW );
        if( key_str.empty() )
            return false; // cancel command

        rt[RT_PARAM]->SetKey( key_str.c_str() );
        std::string fstKeyFld = projectName();
        new_project_dir_name = fstKeyFld;

        //Test equal project names
        templ_str = fstKeyFld;
        templ_str += ":*:";
        TCStringArray aKey__;
        TCIntArray anR__;

        if(  db->GetKeyList( templ_str.c_str(), aKey__, anR__  ) >0 )
        {
            vfMessage(window(), fstKeyFld.c_str(),
                      "Project cannot be created - such directory already exists."
                      "\nPlease, enter another name.");
            goto AGAIN;
        }
        templ_str = key_templ;
        if( !templ_str.empty() )
        {
            templ_key = true;

            int  Rnum = rt[RT_PARAM]->Find( templ_str.c_str() );
            ErrorIf( Rnum < 0, templ_str.c_str() ,
                     "Project record does not exist!");
            rt[RT_PARAM]->Get( Rnum ); // read record
            dyn_set();
            SetFN();                  // reopen files of data base
            // if no elements profile as template
            if( rt[RT_ICOMP]->ifDefaultOpen() )
                Error( templ_str, "This project cannot be extended using Elements Dialog.");
        }
        else
        {
            rt[RT_PARAM]->SetKey( key_str.c_str() );
            dyn_kill();
            set_def(); // set default data or zero if necessary
        }

        if( remakeRec )
            RecBuild( key_str.c_str(), VF_REMAKE );  // Edit flags
        else
            RecBuild( key_str.c_str(), VF_BYPASS );

        pVisor->Message( window(), "Loading Modelling Project",
                         "Opening database files to Project", 5  );

        rt[RT_PARAM]->SetKey( key_str.c_str() );

        if( templ_key == false  )
            InitFN( fstKeyFld.c_str(), nullptr  ); // make Project directory
        else  // using existing Project
        {
            rt[RT_PARAM]->SetKey( templ_str.c_str() );
            std::string fstKeyFld_t = projectName();
            InitFN( fstKeyFld.c_str(), fstKeyFld_t.c_str()  ); // make Project directory
            RenameFN( fstKeyFld.c_str(), fstKeyFld_t.c_str()  );
        }
        rt[RT_PARAM]->SetKey( key_str.c_str() );

        if( !rCopyFilterProfile( fstKeyFld.c_str() ) )
            Error( key_str, "Project configuration aborted by the user!" );//goto BACK;

        // get opens files list
        if( !GetFN( fstKeyFld.c_str(), false ) )
            Error( key_str, "Project configuration aborted by the user!" );
        SetFN();

        if( templ_key == true  )
        {
            rt[RT_PARAM]->SetKey( key_str.c_str() );
            SaveOldList();

            // delete auto-generated aq and gas phases if already created
            deleteAutoGenerated();
        }
        pVisor->Message( nullptr, "Loading Modelling Project",
                         "Loading lists of IComp, Compos, Phase\n"
                         "  and DComp/ReacDC record keys", 10);

        // load lists of ICOMP, COMPOS, PHASE and DCOMP&REACT recordc keys
        rt[RT_PARAM]->SetKey( key_str.c_str() );
        rmults->LoadRmults( !templ_key /*true*/, true );

        pVisor->Message( nullptr, "Loading Modelling Project",
                         "Detecting changes in thermodynamic database", 40 );

        if( templ_key == true )
        {
            TestChangeProfile();  // test and insert changes to data base file
            DeleteOldList();
        }

        // save results   RecSave(str.c_str());
        AddRecord( key_str.c_str() );

    }
    catch( TError& /*xcpt*/ )
    {
        pVisor->CloseMessage();
        contentsChanged = false;
        //delete project directory, if Project record create error
        std::string Path = pVisor->userProfDir();
        Path +=   new_project_dir_name;
        pVisor->deleteDBDir(Path.c_str());
        throw;
    }
    return true;
}


// load  SysEq and unpack data record from data base
// (for Process, GTdemo, UnSpace ... calculations)
void TProfil::loadSystat( const char *key )
{
    MULTI *pmp = multi_internal->GetPM();
    //char pkey[81];
    TSysEq* STat = dynamic_cast<TSysEq *>(aMod[RT_SYSEQ].get());
    //  STat->ods_link(0);
    std::string str;

    if( key==nullptr )
    {
        //rt[RT_SYSEQ]->MakeKey( RT_PARAM, pkey, RT_PARAM, 0,
        //                       K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_ANY, K_END);
        str = STat->getFilter();
        str = STat->GetKeyofRecord( str.c_str(),//pkey,
           "Existing CSD and equilibria records in project database", KEY_OLD );
        ErrorIf( str.empty(), GetName(), "Operation cancelled!");
    }
    else str=std::string(key);
    STat->keyTest( str.c_str() );

    // get record
    STat->RecInput( str.c_str() );


    // unpack to SYSTEM structure
    syst->loadData( false );  // set def and unpack syseq to system

    // Test MULTY for change (if new System cfg or T, P - new)
    pmp->pESU = 0;  //  new record was readed
    std::string keyp = char_array_to_string( rt[RT_SYSEQ]->UnpackKey(), rt[RT_SYSEQ]->KeyLen() );
    PMtest( keyp.c_str() );
    //pmp->pTPD = 0;   // workaround 26.02.2008  DK SD 24/05/2010
    //if( pmp->pBAL < 2 || pmp->pTPD < 2)
    multi_internal->InitalizeGEM_IPM_Data();

    if( pmp->pESU )      // unpack old solution
    {
        multi_internal->loadData( false );  // unpack syseq to multi
        for(short j=0; j< pmp->L; j++ )
            pmp->X[j] = pmp->Y[j];
        multi_internal->EqstatExpand(/* keyp.c_str(),*/ true );
//        outMultiTxt( "GEM_EqstatExpand.txt"  );
    }

    pVisor->Update();
//    outMultiTxt("GEMHUB_loadSystat.txt");
}

// rebuild loading before Systat
void TProfil::deriveSystat()
{
     MULTI *pmp = multi_internal->GetPM();
     TSysEq::pm->setCalcFlag( false );

    std::string keyp = rt[RT_SYSEQ]->UnpackKey();
    if( keyp.find_first_of( "*?") != std::string::npos )
        Error("SyStat", "Undefined current record!");
    int ret = TSysEq::pm->RecBuild( keyp.c_str(), VF_REMAKE );

    // unpack to SYSTEM structure
    syst->loadData( false, ret );  // set def and unpack syseq to system

    // Test MULTY for change (if new System cfg or T, P - new)
    pmp->pESU = 0;  //  new record was readed
    PMtest( keyp.c_str() );
    //pmp->pTPD = 0;   // workaround 26.02.2008  DK 24/05/2010
    //if( pmp->pBAL < 2 || pmp->pTPD < 2)
        multi_internal->InitalizeGEM_IPM_Data();
    if( pmp->pESU )      // unpack old solution
    {
        multi_internal->loadData( false );  // unpack syseq to multi
        for(short j=0; j< pmp->L; j++ )
            pmp->X[j] = pmp->Y[j];
        multi_internal->EqstatExpand( /*keyp.c_str(),*/ true );
    }

    // SD 22/01/2010 bool
    if( syst->GetSY()->Pask != S_OFF )
     syst->setDefCheck();
    systbcInput( window(), keyp.c_str() );
    pVisor->Update();
    //pVisor->OpenModule(window(), MD_SYSTEM);
}


//  build new Systat record
void TProfil::newSystat( int mode )
{
    TSysEq::pm->setCalcFlag( false ); // => pmp->pESU = 0;

    std::string key_str = rt[RT_SYSEQ]->PackKey();
    if( key_str.find("*") != std::string::npos )
    {
        key_str = char_array_to_string( db->FldKey(0), db->FldLen(0) );
        strip( key_str );
        key_str += ":G:MySystem:0:0:1:25:0:";
    }
    std::string str = key_str;
    std::string capName = "Please, enter a new record key: ";

AGAIN:
    str = TSysEq::pm->GetKeyofRecord( str.c_str(),  capName.c_str(), KEY_NEW );
    if( str.empty() )
        return;
    if( rt[RT_SYSEQ]->Find( str.c_str() ) >= 0 )
    {
        capName = "This record already exists! Please, enter another name.";
        goto AGAIN;
        //Error("SyStat", "This record already exists!");
    }

    int ret = TSysEq::pm->RecBuild( str.c_str(), mode );
    syst->loadData( true, ret ); // set def and unpack syseq to system
    // Test MULTY for change (if new System cfg or T, P - new)
    std::string keyp = rt[RT_SYSEQ]->UnpackKey();
    PMtest( keyp.c_str() );
    //pmp->pTPD = 0;   // workaround 26.02.2008  DK
    //if( pmp->pBAL < 2 || pmp->pTPD < 2)
       multi_internal->InitalizeGEM_IPM_Data();


    // SD 22/01/2010 bool
    systbcInput( window(), str.c_str() );
    pVisor->Update();
    //pVisor->OpenModule(window(), MD_SYSTEM);
}


// packed syseq arrays
void TProfil::PackSystat()
{
    TSysEq* STat = dynamic_cast<TSysEq *>(aMod[RT_SYSEQ].get());
    //  STat->ods_link(0);

    //  syst->SyTest(); //  Sveta 15/05/99 ??? do it
    syst->setSizes();
    if( isSysEq ) // add to z_sp_config show mode 07/12/99
    {
        STat->ssp->DM[22] += PHoff.size();
        STat->ssp->DM[23] += DCoff.size();
    }
    multi_internal->setSizes();
    STat->dyn_new();
    if( isSysEq ) // add to z_sp_config show mode 07/12/99
        syst->packData( PHon, PHoff, DCon, DCoff);
    else syst->packData();
    if( isSysEq ) // add to z_sp_config show mode 07/12/99
        multi_internal->packData( PHon, DCon );
    else multi_internal->packData();

    pVisor->Update();

    //Sveta
}

//Calculate system bulk composition        line # 300

void TProfil::CalcBcc()
{
    //     Switchoffs etc. - most important for the users!
    syst->SyTest();
    pVisor->Update();
    TSysEq::pm->CellChanged();
    syst->SyTest();               // Must be done twice
    pVisor->Update(true);         // added 24.01.00
    TSysEq::pm->CellChanged();    // DAK
}

// Calculation of equilibrium state with GEM IPM2 kernel within GEM-Selektor
// GEMS: Caution - this function is run in another thread!
// don't call any GUI (Qt or VisorImp) functions from here!
// exceptions should be kept inside the function either
// Modified on 10.09.2007 to return GEM IPM2 calculation time in seconds as double
// Parameters: kTimeStep: index of time step (>= 0) or -1 to reset kinetics;
//             kTime: current time (>= 0.0);
//             kdTime: current time step (can be changed in TKinMet class)
// Returns: elapsed calculation time in seconds
//
double TProfil::CalcEqstat( double &kdTime, const long kTimeStep, const double kTime )
{
    TSysEq* STat = dynamic_cast<TSysEq *>(aMod[RT_SYSEQ].get());
    long int NumIterFIA,  NumIterIPM;

    STat->ods_link(0);
    status = nullptr;
    syst->SyTest();
    if( !syst->BccCalculated() )
        Error( "System", "Please, specify bulk composition of the system!");

    std::string keyp = rt[RT_SYSEQ]->UnpackKey();
    // new: setting chemical kinetics time counter and variables
    gui_logger->trace("kdTime: {}   kTimeStep: {} kTime: {}", kdTime, kTimeStep, kTime);
    if( kdTime <= 0.  )
    {  // no kinetics to consider
        multi_internal->GetPM()->kTau = 0.;
        multi_internal->GetPM()->kdT = 0.;
        multi_internal->GetPM()->ITau = -1; // SD 23/03/2015
        multi_internal->GetPM()->pKMM = 2;  // no need to allocate TKinMet instances
    }
    else {   // considering kinetics
        multi_internal->GetPM()->kTau = kTime;
        multi_internal->GetPM()->kdT = kdTime;
        if( kTimeStep < 0 )
        {   // we need to initialize TKinMet
            multi_internal->GetPM()->pKMM = -1;
            multi_internal->GetPM()->ITau = -1;
        }
        else  // TKinMet exists, simulation continues
        {
            multi_internal->GetPM()->pKMM = 1; // SD 23/03/2015 multi->GetPM()->ITau = kTimeStep;
        }
    }

    PMtest( keyp.c_str() );
    multi_internal->InitalizeGEM_IPM_Data();

   // run GEM calculation
   ComputeEquilibriumState( /*NumPrecLoops,*/ NumIterFIA, NumIterIPM );

// new - possibly returns a new time step suggestion
   if( noZero(kdTime) )
       kdTime = multi_internal->GetPM()->kdT;
   return  multi_internal->GetPM()->t_elap_sec;
}

//add new Project structure
// Save file configuration to Project structure
void TProfil::InitFN( const char * prfName, const char* prfTemplate )
{

    std::string Path = pVisor->userProfDir();
    Path += prfName;

    // make directory Path (find system function)
    pVisor->makeDBDir(Path.c_str());

    if( prfTemplate == nullptr )
    { // creating empty files
        for(size_t i=0; i<aMod.size(); i++)
        {
            if( aMod[i]->IsSubModule() )
                continue;
            rt[aMod[i]->rtNum()]->MakeInNewProfile( Path.c_str(), prfName );
        }
    }
    else // copy records from template project
    {
        std::string tmpDirPath = pVisor->userProfDir();
        tmpDirPath += prfTemplate;
        TCStringArray all_files = pVisor->readPDBDir(tmpDirPath.c_str(), "*" );

        // make list of opened files
        std::set<std::string> open_files_keywds;
        for( int ii=0; ii< rmults->GetMU()->NfT; ii++) {
            auto s_keywd = char_array_to_string( rmults->GetMU()->FN[ii], MAX_FILENAME_LEN);
            open_files_keywds.insert( s_keywd );
            //std::cout << s_keywd << " ";
        }
        //std::cout << std::endl;

        TCStringArray aFiles;
        for (uint ii = 0; ii < all_files.size(); ii++)
        {
            size_t pose = all_files[ii].rfind(".");
            if( pose != std::string::npos )
            {
                // do not copy not connected files database
                auto ext = all_files[ii].substr( pose+1 );
                if (ext == "pdb" || ext == "ndx") {
                    TDBFile db_link(all_files[ii]);
                    //std::cout << db_link.GetKeywd() << "  ";
                    if( open_files_keywds.find(db_link.GetKeywd()) == open_files_keywds.end() ) {
                        //std::cout << " " << std::endl;
                        continue;
                    }
                }
            }
            //std::cout << all_files[ii] << std::endl;
            aFiles.push_back(all_files[ii]);
        }

        // copy files to new Prifile
        for (uint ii = 0; ii < aFiles.size(); ii++)
        {
            std::string f_tmp = tmpDirPath;
            f_tmp += "/";
            f_tmp += aFiles[ii];
            std::string f_new = Path;
            f_new += "/";
            replace( aFiles[ii], prfTemplate, prfName);
            f_new += aFiles[ii];

            if ( !(std::string( aFiles[ii], 0, aFiles[ii].find(".")) ==  db->GetKeywd() ))
                pVisor->CopyF( f_new.c_str(), f_tmp.c_str() );
        }

        // add files to module list
        for (size_t ii = 0; ii < aFiles.size(); ii++)
        {
            if (std::string(aFiles[ii], aFiles[ii].rfind(".") + 1) == "pdb") {
                for (size_t jj = 0; jj < rt.size(); jj++) {
                    if (std::string(aFiles[ii], 0, aFiles[ii].find(".")) == rt[jj]->GetKeywd())
                    {
                        std::string f_new = aFiles[ii];
                        rt[jj]->MakeInNewProfile( Path.c_str(), prfName, f_new.c_str() );
                    }

                }
            }
        }
    }
}

// Rename records SysEq and >
void TProfil::RenameFN( const char * prfName, const char* prfTemplate )
{
    // Rename records SysEq in New Project
    TSysEq::pm->RenameList(prfName, prfTemplate);
    // Rename records in New Project > SysEq
    for(size_t i=RT_SYSEQ+1; i<aMod.size(); i++)
    {
        if( aMod[i]->IsSubModule() )
            continue;
        rt[i]->RenameList(prfName, prfTemplate);
    }
}
// Save file configuration to Project structure
bool TProfil::GetFN( const char * prfName, bool show_dlg )
{

    TCStringArray aFls;
    TCIntArray aCnt;
    if( ! vfListFiles(pVisor->window()/*window()*/, show_dlg, prfName, aFls, aCnt ))
        return false;

    RMULTS* mup = rmults->GetMU();
    memset(mup->Nfl, 0, MAXNUMCHAINS*sizeof(short));
    mup->NfT = 0;
    for(size_t i=0; i<aCnt.size(); i++)
    {
        mup->Nfl[i] = aCnt[i];
        mup->NfT += mup->Nfl[i];
    }
    mup->FN = static_cast<char (*)[MAX_FILENAME_LEN]>(aObj[ o_mufn]->Alloc(
                                                          aFls.size(), 1, MAX_FILENAME_LEN ));
    // insert files name to FN
    for(size_t j=0; j<aFls.size(); j++)
        strncpy( mup->FN[j], aFls[j].c_str(), MAX_FILENAME_LEN);
    return true;
}


// Reopen file configuration on data in Project structure
void TProfil::SetFN()
{
    bool allOpend = true;
	unsigned i, nx=0;
    short j, k=0;
    TCStringArray aFls;
    std::string s;

    std::string fstKeyFld = projectName();
    for( i=0; i<aMod.size(); i++)
    {
        if( aMod[i]->IsSubModule() )
            continue;
///Added after GEM2MT implemented
        if( i == RT_PARAM )
        {
            s = char_array_to_string( rmults->GetMU()->FN[k], MAX_FILENAME_LEN);
            if( s[0] == 'i' && s[1] == 'n') // integ file , use old version DB
            { k+=rmults->GetMU()->Nfl[i];
              nx = 1;
            }
        }
///end Added after GEM2MT implemented
        aFls.clear();
        for(j=0; j<rmults->GetMU()->Nfl[i+nx]; j++)
        {
            s = char_array_to_string( rmults->GetMU()->FN[k++], MAX_FILENAME_LEN);
            aFls.push_back(s);
        }

        if( !rt[aMod[i]->rtNum()]->SetNewOpenFileList( aFls ))
            allOpend = false;
        aMod[i]->dyn_set();
    }
    if( !allOpend )
    {
       GetFN( fstKeyFld.c_str(), false );
    }
}

//------------------ End of m_prfget.cpp --------------------------


